it is a NoSQL database that is document-oriented (stores data in JSON-like documents). it follows AP side of CAP theorem, prioritising availability and partition tolerance while allowing for eventual consistency.

# BSON
it stands for binary JSON, and is a binary-encoded serialisation of JSON-like documents
- **binary encoding**: more compact and efficient for storage and transmission compared to plain text JSON
- **additional data types**: supports additional data types such as date, binary data, regular expressions, etc.
- **ordered key-value pair**: preserves the order of key-value pairs within the documents
- **efficient encoding of large documents**: uses a compact binary format that reduces the overhead associated with storing and transmitting data

# `_id` field
serves as the primary key for documents within a collection. each document in a collection must have a unique `_id` value. it can be assigned manually by the user or automatically generated by MongoDB if not explicitly provided.

if not specified, MongoDB will automatically generate a `_id` value using an ObjectId. ObjectId is a 12-byte identifier consisting of:
1. **timestamp**: first 4 bytes represent the timestamp (Unix epoch), ensures that ObjectId values are roughly ordered by creation time
2. **machine identifier**: next 3-bytes represent a unique identifier for the machine or process generating the ObjectId, helps ensuring uniqueness even in distributed systems
3. **process identifier**: next 2-bytes represent the PID of the process generating the ObjectId, further helps in ensuring uniqueness
4. **counter**: last 3 bytes represent a counter that is incremented for each ObjectId generated within the same second, to ensure uniqueness within the same process

# CRUD operations
## insert documents

- insert a single document into a collection
```bash
db.collection.insertOne(
	<json_document>
)
```
- insert multiple documents
```bash
db.collection.insertMany([
	<json_document_1>,
	<json_document_2>,
	...
])
```

## query documents

- read all documents
```bash
db.collection.find()
```
this command is equivalent to
```sql
SELECT * FROM <table>;
```
- specify equality operator
```bash
db.collection.find( { <key>: <value> } )
```
this command is equivalent to
```sql
SELECT * FROM <table> WHERE <key> = <value>;
```
- specify conditions using query operators
	- `$eq`: matches values that are equal to a specified value
	- `$gt`: matches values that are greater than a specified value
	- `$gte`: matches values that are greater than or equal to a specified value
	- `$in`: matches any of the values specified in an array
	- `$lt`: matches values that are lesser than a specified value
	- `$lte`: matches values that are lesser than or equal to a specified value
	- `$ne`: matches all values that are not equal to a specified value
	- `$nin`: matches none of the values specified in the array
```bash
db.collection.find( { <key>: { <operator>: <value> }, ... } )
```
- specify logical operators (`AND` / `OR`)
```bash
db.collection.find(
	<key>: <value>,
	$or: [ { <key>: <value> }, ... ]
)
```

## update documents

- update a single document (updates the first document in collection where `key` = `value`)
```bash
db.collection.updateOne(
	{ <key>: <value> },
	{ $set: { <key>: <new_value>, ... } }
)
```
- update multiple documents
```bash
db.collection.updateMany(
	{ <key>: <value> },
	{ $set: { <key>: <new_value>, ... } }
)
```
- replace an entire document (except `_id` field)
```bash
db.collection.replaceOne(
	{ <key>: <value> },
	<new_json_document>
)
```

## delete documents
- delete one document that match a condition
```bash
db.collection.deleteOne( { <key>: <value> } )
```
- delete all documents that match a condition
```bash
db.collection.deleteMany( { <key>: <value> } )
```
- delete all documents
```bash
db.collection.deleteMany({})
```

# aggregation operations
## count
return count of documents that would match the query
```bash
db.collection.find(<query>).count()
db.collection.count(<query>)
```

## distinct
find the distinct values for a specified field within a single collection
```bash
db.collection.distinct(<key>, { <key>: <value>, ... })
```

# aggregation pipeline
specific flow of operations that processes, transforms, and returns results. successive operations are informed by the previous result.

typical aggregation pipeline:
`input` -> `$match` -> `$project` -> `$group` -> `$sort` -> `$limit` -> `$out`

```bash
db.collection.aggregate([
	{ $match: { <key>: <value> } },
	{ $group: { _id: $<key>, <output>: { <operation>: $<key> } } }
])
```

some of the operations are:
- `$sum`: sums up the defined value from all documents
- `$avg`: calculates the average of all given values from all documents
- `$min`: gets the minimum of the corresponding values from all documents
- `$max`: gets the maximum of the corresponding values from all documents

## aggregation stages
- `$match`: used for filtering the documents that are given as input to the next stage
- `$project`: used to select some specific fields from a collection
- `$group`: group documents based on some value
- `$sort`: used to sort the document that is rearranging them
- `$limit`: used to pass first n numbers of documents
- `$out`: used to write resulting documents to a new collection

| SQL      | MongoDB  |
| -------- | -------- |
| WHERE    | $match   |
| GROUP BY | $group   |
| HAVING   | $match   |
| SELECT   | $project |
| ORDER BY | $sort    |
| LIMIT    | $limit   |
| COUNT    | $sum     |
